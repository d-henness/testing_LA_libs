module gpu_kernals
  use datatypes
  implicit none
    contains
      attributes(device) subroutine findchannel(socket, num_sm, s_found, s_chan)
        implicit none
        integer ::  i, istat
        integer ::  num_sm
        integer ::  s_chan
        integer, dimension(:) ::  socket
        logical ::  s_found
        integer ::  s_plug

        s_chan = 0
        s_found = .false.

        i = 1
        do while (s_found .eqv. .false.)
          s_plug = atomicadd(socket(i), 1)
          if (s_plug .eq. 0) then
            s_chan = i
            s_found = .true.
          elseif(s_plug .gt. 0) then
            istat = atomicsub(socket(i), 1)
            i = i + 1
            if (i .gt. num_sm) then
              i = 1
            endif
          endif
        enddo

      end subroutine findchannel

      attributes(device) subroutine releasechannel(socket, s_chan)
        implicit none
        integer, dimension(:) ::  socket
        integer ::  s_chan, istat

        istat = atomicsub(socket(s_chan), 1)

      end subroutine releasechannel    

      attributes(device) subroutine auxv_gpu(imax, x, v, thread, s_chan)
        real(dp), dimension(:, :, 0:) ::  v
        real(dp)  ::  x
        real(dp)  ::  x1
        integer ::  imax, imin, i, thread, s_chan

        x1 = 1.0_dp/x
        if(mod(imax, 2) .eq. 0) then
          v(thread, s_chan, 0) = dsqrt(x1)
          imin = 2
        else
          v(thread, s_chan, 1) = x1
          imin = 3
        endif
        do i = imin, imax, 2
          v(thread, s_chan, i) = v(thread, s_chan, i - 2) * x1 * real(i - 1)
        enddo

      end subroutine auxv_gpu

      attributes(device) subroutine auxv1gpu(imax, x, v, s, s_chan)
        implicit none
        integer, intent(in) ::  imax, s, s_chan
        integer ::  i
        real(dp), intent(in)  ::  x
        real(dp)  ::  x1
        real(dp),intent(out), dimension(:, :, 0:)  ::  v
    
        x1 = 1.0_dp/x
        v(s, s_chan, 0) = dsqrt(x1)
        v(s, s_chan, 1) = x1
    
        do i = 2, imax, 2
          v(s, s_chan, i) = v(s, s_chan, i - 2) * x1 * real(i - 1, 8)
        enddo
        do i = 3, imax, 2
          v(s, s_chan, i) = v(s, s_chan, i - 2) * x1 * real(i - 1, 8)
        enddo
      end subroutine auxv1gpu

      attributes(device) subroutine auxc_gpu(maxa, maxb, t, c, s, s_chan)
        implicit none
        integer ::  i, j
        integer, intent(in) ::  maxa, maxb, s, s_chan
        real(dp), intent(in)  ::  t
        real(dp), intent(out), dimension(:, :, :, 2:) ::  c
        real(dp)  ::  t1, t2, d

        t1 = 1.0_dp/(1.0_dp + t)
        t2 = t1 * t

        c(s, s_chan, 1, 2) = t1 * dsqrt(t1)

        if (maxa .gt. 1) then
          d = c(s, s_chan, 1, 2)
          do i = 3, maxa, 2
            d = d * t2 * real(i, 8)/real(i - 1, 8)
            c(s, s_chan, i, 2) = c(s, s_chan, i - 2, 2) +d
          enddo
        endif

        do j = 4, maxb, 2
          c(s, s_chan, 1, j) = c(s, s_chan, 1, j - 2) * t1
        enddo

        do j = 4, maxb, 2
          do i = 3, maxa, 2
            c(s, s_chan, i, j) = c(s, s_chan, i, j -2) * t1 + c(s, s_chan, i -2, j) * t2
          enddo
        enddo

      end subroutine auxc_gpu

      attributes(device) subroutine xint_gpu(s_xints, v, nterm, nqntm, cnorm, thread, s_chan, p, q, l, j)
        real(dp), dimension(:, :, :, :) ::  cnorm
        real(dp)  ::  xs
        real(dp)  ::  s_xints
        real(dp), dimension(:, :, 0:)  ::  v
        integer, dimension(*) ::  nqntm
        integer ::  p, q, nterm, npq, thread, s_chan, l, j, ip, iq


        xs=0.0_dp
        do ip = 1, nterm
          do iq = 1, nterm
            npq = nqntm(ip)+ nqntm(iq)
            xs = xs + v(thread, s_chan, npq) * cnorm(p, l, ip, j) * cnorm(q, l, iq, j)
          enddo
        enddo
        s_xints = xs

      end subroutine xint_gpu

      attributes(device) subroutine xintu_gpu(s_xintu, rnuc, alpha, nucmdl, zpq, v, c1, c2,  &
        & nterm, nqntm, cnorm, thread, s_chan, p, q, l, j)
        real(dp)  ::  alpha, xu, fctr, xintu, rnuc, zpq
        real(dp), dimension(:, :, :, :)  ::  cnorm
        real(dp)  ::  s_xintu
        real(dp), dimension(:, :, 0:)  ::  v
        real(dp), dimension(:, :, :, 2:)  ::  c1, c2
        integer, dimension(*)  ::  nqntm
        integer ::  nucmdl, nterm, ip, iq, npq, thread, s_chan, l, j, p, q
        real(dp), parameter ::  ufctr = 0.797884560802865_dp 

        xu = 0.0_dp

        if (nucmdl .eq. 1) then
          do ip = 1, nterm
            do iq = 1, nterm
              npq = nqntm(ip) + nqntm(iq) - 1
              xu = xu + v(thread, s_chan, npq) * cnorm(p, l, ip, j) * cnorm(q, l, iq, j)
            enddo
          enddo
          xu = xu + xu

        elseif (nucmdl .eq. 3) then
          fctr = dsqrt(alpha * 0.5_dp)
          do ip = 1, nterm
            do iq = 1, nterm
              npq = nqntm(ip) + nqntm(iq)
              xu = xu + (v(thread, s_chan, npq - 1) * c1(thread, s_chan, npq  &
                & - 1, 2) + fctr * v(thread, s_chan, npq) * c2(thread,  &
                & s_chan, 1, npq)) * cnorm(p, l, ip, j) * cnorm(q, l, iq, j)
            enddo
          enddo
          xu = xu + xu
        endif

        s_xintu = xu*ufctr

      end subroutine xintu_gpu

      attributes(global) subroutine eint1gpu(smx, hmx, nsym, nbs, &
      & maxbs, nterm, nqntm, cnorm, znuc, rnuc, alpha, nucmdl,  &
      & c, locmx, loctr, lpq_array, v, c1, c2, num_sm, socket, s_xints,  &
      & s_xintus, total)

      integer ::  i, j, l, p, q, num_sm, nsym, maxbs, nucmdl, numx, threadx, total
      integer, dimension(:) ::  socket, locmx, loctr, nbs
      integer, dimension(:, :, :) ::  nqntm
      integer, dimension(:, :)  ::  nterm
      integer, shared ::  s_chan, s_plug
      integer, shared, dimension(512)  ::  s_nqmax, s_imax, s_lpqll, s_lpqsl, s_lqpsl, s_lpqss
      real(dp), dimension(:)  ::  smx, hmx
      real(dp), dimension(:, :, 0:) ::  v
      real(dp), dimension(:, :, :, :)  ::  c1, c2, cnorm
      real(dp), dimension(:, :) ::  lpq_array
      real(dp)  ::  c, rnuc, znuc, alpha, xint, xintu
      real(dp), dimension(7)  ::  snfctr
      data snfctr /3.0_dp, 5.0_dp, 5.0_dp, 7.0_dp, 7.0_dp, 9.0_dp, 9.0_dp/
      real(dp), shared, dimension(512, 2)  ::  s_xs, s_xu
      real(dp), shared, dimension(512) ::  s_xtpq, s_xtqp, s_zpq, s_xsss
      real(dp), dimension(:, :)  ::  s_xintus, s_xints
      logical, shared ::  s_found

      if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
        call findchannel(socket, num_sm, s_found, s_chan)
      endif

      call syncthreads()

      threadx = threadIdx%x

      ! Use grid stride looping

      do numx = threadIdx%x + (blockDim%x * (blockIdx%x - 1)), total, blockDim%x*gridDim%x

        l = int(lpq_array(numx, 3))
        p = int(lpq_array(numx, 4))
        q = int(lpq_array(numx, 5))

        s_xs = 0.0_dp
        s_xu = 0.0_dp
        s_xtpq= 0.0_dp
        s_xtqp = 0.0_dp
        s_xsss = 0.0_dp

        call syncthreads()

        s_nqmax(threadx) = nqntm(nterm(2, l), 2, l)
        s_imax(threadx) = s_nqmax(threadx) * 2
        s_zpq(threadx) = lpq_array(numx, 2) + lpq_array(numx, 1)

!        v(threadx, s_chan, 0) = lpq_array(2, 1)
!        v(threadx, s_chan, 1) = lpq_array(2, 2)
!        v(threadx, s_chan, 2) = lpq_array(2, 3)
!        v(threadx, s_chan, 3) = lpq_array(2, 4)
!        v(threadx, s_chan, 4) = lpq_array(2, 5)


        call auxv_gpu(s_imax(threadx), s_zpq(threadx) * 0.5_dp, v, threadx, s_chan)

        ! Point Nucleus
        if (nucmdl .eq. 1) then
          call auxv_gpu(s_imax(threadx) - 1, s_zpq(threadx) * 0.5_dp, v, threadx, s_chan)
        elseif (nucmdl .eq. 3) then
          call auxv_gpu(s_imax(threadx) - 1, s_zpq(threadx) * 0.5_dp, v, threadx, s_chan)
          call auxc_gpu(s_imax(threadx) - 1 , 2, s_zpq(threadx)/alpha, c1, threadx, s_chan)
          call auxc_gpu(1 , s_imax(threadx), alpha/s_zpq(threadx), c2, threadx, s_chan)
        endif

        do j = 1, 2
          call xint_gpu(s_xsss(threadx), v, nterm(j, l), nqntm(1, j, l), cnorm, &
            & threadx, s_chan, p, q, l, j)
           s_xs(threadx, j) = s_xs(threadx, j) + s_xsss(threadx)
           call xintu_gpu(s_xintus(threadx, s_chan), rnuc, alpha, nucmdl, s_zpq(threadx), v, c1, c2,  &
             & nterm(j, l), nqntm(1, j, l), cnorm, threadx, s_chan, p, q, l, j)
           s_xu(threadx, j) = s_xu(threadx, j) + s_xintus(threadx, s_chan)
        enddo



        s_xtpq(threadx) = s_xtpq(threadx) + s_xsss(threadx) * dsqrt(lpq_array(numx, 2) * snfctr(l))
        s_xtqp(threadx) = s_xtqp(threadx) + s_xsss(threadx) * dsqrt(lpq_array(numx, 1) * snfctr(l))


        s_lpqll(threadx) = locmx(l) + loctr(p) + q
        s_lpqsl(threadx) = locmx(l) + loctr(nbs(l) + p) + q
        s_lqpsl(threadx) = locmx(l) + loctr(nbs(l) + q) + p
        s_lpqss(threadx) = locmx(l) + loctr(nbs(l) + p) + (nbs(l) + q) 

        smx(s_lpqll(threadx)) = s_xs(threadx, 1)
        smx(s_lpqsl(threadx)) = 0.0_dp
        smx(s_lqpsl(threadx)) = 0.0_dp
        smx(s_lpqss(threadx)) = s_xs(threadx, 2)
        hmx(s_lpqll(threadx)) = -znuc * s_xu(threadx, 1)
        hmx(s_lpqsl(threadx)) = c * s_xtpq(threadx)
        hmx(s_lqpsl(threadx)) = c * s_xtqp(threadx)
        hmx(s_lpqss(threadx)) = -znuc * s_xu(threadx, 2) - c * c * 2 * s_xs(threadx, 2)
      enddo

      call syncthreads()

      if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
        call releasechannel(socket, s_chan)
      endif

      end subroutine eint1gpu

      attributes(global) subroutine eint2gpu(xp, nsym, nbs, nterm, nqntm, cnorm, b, numin, numax, locxp, loctr, maxnbs, v1, v2, c1, c2, xj, xk1, xk2, ls1, ls2, socket, num_sm, lmpqrs_array, total2)
        implicit none
        
        integer, dimension(:) ::  socket 
        logical, shared ::  s_found
        integer, shared ::  s_chan, s_plug
        integer ::  nsym, maxnbs, num_sm, total2
        integer,dimension(nsym) ::  nbs
        integer ::  i, j, nu, istat
        real(dp), dimension(512, 14, 4)  ::  xj, xk1, xk2 
        integer, shared, dimension(512) ::  npq, nrs 
        integer ::  nterm1, nterm2 
        integer ::  ip, iq, ir, is
        integer, dimension(:, :, :) ::  nqntm
        real(dp), shared, dimension(512)  ::  s_zpq, s_zrs
        real(dp), shared, dimension(512)  ::  xint, term
        real(dp), dimension(0:6, 7, 7)  ::  b
        integer, shared, dimension(512)  ::  s_ntermp, s_ntermq, s_nterms, s_ntermr
        integer, shared, dimension(512) ::  s_minnu, s_maxnu
        integer, dimension(7, 7) ::  numin, numax
        integer, dimension(2, 7)  ::  nterm
        real(dp), dimension(512, 14, 0:20)  ::  v1, v2     
        real(dp), dimension(512, 14, 9, 2:20)  ::  c1, c2  
        integer, dimension(4)  ::  ls1, ls2 
        integer, shared, dimension(4) ::  s_ls1, s_ls2
        real(dp), dimension(:, :, :, :) ::  cnorm
        real(dp), parameter ::  xfctr = 1.595769121605731_dp
        integer, dimension(:)  ::  locxp, loctr
        real(dp), dimension(:, :) ::  xp 
        real(dp), dimension(total2, 10) ::  lmpqrs_array
        integer, shared, dimension(512) ::  s_l, s_m, s_p, s_q, s_r, s_s
    
    
        ! In order to prevent race condition bugs, a "channel" needs to be selected.
        ! findchannel and release channel work by looping over 1 to the number of
        ! SMs over and over until it finds one that is free. Note that with the way
        ! this is currently written, the occupancy must be known and set before
        ! hand.
    
    
        if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
          call findchannel(socket, num_sm, s_found, s_chan)
        endif

    
        call syncthreads()
    
        if ((threadIdx%x .gt. 0) .and. (threadIdx%x .lt. 5)) then
          s_ls1(threadIdx%x) = ls1(threadIdx%x)
          s_ls2(threadIdx%x) = ls2(threadIdx%x)
        endif
    
        call syncthreads()
    
        do j = ((blockIdx%x - 1) * blockDim%x) + threadIdx%x, total2, blockDim%x*gridDim%x
    
          s_l(threadIdx%x) = int(lmpqrs_array(j, 1))
          s_m(threadIdx%x) = int(lmpqrs_array(j, 2))
          s_p(threadIdx%x) = int(lmpqrs_array(j, 3))
          s_q(threadIdx%x) = int(lmpqrs_array(j, 4))
          s_r(threadIdx%x) = int(lmpqrs_array(j, 5))
          s_s(threadIdx%x) = int(lmpqrs_array(j, 6))

          do i = 1, 4
            xj(threadIdx%x, s_chan, i) = 0.0_dp
            xk1(threadIdx%x, s_chan, i) = 0.0_dp
            xk2(threadIdx%x, s_chan, i) = 0.0_dp
          enddo
    
          npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) * 2
          nrs(threadIdx%x) = nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x)) * 2
          s_zpq(threadIdx%x) = (lmpqrs_array(j, 7) + lmpqrs_array(j, 8)) * 0.5_dp
          s_zrs(threadIdx%x) = (lmpqrs_array(j, 9) + lmpqrs_array(j, 10)) * 0.5_dp
    
          call auxV1gpu(npq(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
          call auxV1gpu(nrs(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
          call auxC_gpu(npq(threadIdx%x) - 1, nrs(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
          call auxC_gpu(nrs(threadIdx%x) - 1, npq(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)
    
          do i = 1, 4
    !                      s_ls1(i) = ls1(i)
    !                      s_ls2(i) = ls2(i)
    
            xint(threadIdx%x) = 0.0_dp
            nterm1 = nterm(s_ls1(i), s_l(threadIdx%x))
            nterm2 = nterm(s_ls2(i), s_m(threadIdx%x))
    
            do ip = 1, nterm1
              do iq = 1, nterm1
                do ir = 1, nterm2
                  do is = 1, nterm2
                    npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(iq, s_ls1(i), s_l(threadIdx%x))
                    nrs(threadIdx%x) = nqntm(ir, s_ls2(i), s_m(threadIdx%x)) + nqntm(is, s_ls2(i), s_m(threadIdx%x))
    
                    term(threadIdx%x) = (v1(threadIdx%x, s_chan, npq(threadIdx%x) - 1) * v2(threadIdx%x, s_chan, nrs(threadIdx%x)) &
                      &               * c1(threadIdx%x, s_chan, npq(threadIdx%x) - 1, nrs(threadIdx%x)) + v2(threadIdx%x, s_chan, nrs(threadIdx%x) - 1) &
                      &               * v1(threadIdx%x, s_chan, npq(threadIdx%x)) * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - 1, npq(threadIdx%x)))  
                    xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), ip, s_ls1(i)) &
                      &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), iq, s_ls1(i)) * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), ir, s_ls2(i)) &
                      &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), is, s_ls2(i))
                  enddo
                enddo
              enddo
            enddo
    
            xj(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
          enddo
    
          s_minnu(threadIdx%x) = numin(s_l(threadIdx%x), s_m(threadIdx%x))
          s_maxnu(threadIdx%x) = numax(s_l(threadIdx%x), s_m(threadIdx%x))
          npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) + nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x))
          s_zpq(threadIdx%x) = (lmpqrs_array(j, 7) + lmpqrs_array(j, 10))*0.5_dp
          s_zrs(threadIdx%x) = (lmpqrs_array(j, 8) + lmpqrs_array(j, 9))*0.5_dp
          call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
          call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
          call auxc_gpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
          call auxc_gpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)
    
          do i = 1, 4
            xint(threadIdx%x) = 0.0_dp
            s_ntermp(threadIdx%x) = nterm(s_ls1(i), s_l(threadIdx%x))
            s_ntermq(threadIdx%x) = nterm(s_ls2(i), s_l(threadIdx%x))
            s_ntermr(threadIdx%x) = nterm(s_ls2(i), s_m(threadIdx%x))
            s_nterms(threadIdx%x) = nterm(s_ls1(i), s_m(threadIdx%x))
            do ip = 1, s_ntermp(threadIdx%x)
              do iq = 1, s_ntermq(threadIdx%x)
                do ir = 1, s_ntermr(threadIdx%x)
                  do is = 1, s_nterms(threadIdx%x)
                    npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(is, s_ls1(i), s_m(threadIdx%x))
                    nrs(threadIdx%x) = nqntm(iq, s_ls2(i), s_l(threadIdx%x)) + nqntm(ir, s_ls2(i), s_m(threadIdx%x))
    
                    term(threadIdx%x) = 0.0_dp
                    do nu = s_minnu(threadIdx%x), s_maxnu(threadIdx%x), 2
                      term(threadIdx%x) = term(threadIdx%x) + (v1(threadIdx%x, s_chan, npq(threadIdx%x) - nu -1) &
                        &               * v2(threadIdx%x, s_chan, nrs(threadIdx%x) + nu) * c1(threadIdx%x, s_chan, &
                        &                 npq(threadIdx%x) - nu -1, nrs(threadIdx%x) + nu) + v2(threadIdx%x, s_chan, &
                        &                 nrs(threadIdx%x) - nu -1) * v1(threadIdx%x, s_chan, npq(threadIdx%x) + nu) &
                        &               * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - nu -1, npq(threadIdx%x) + nu)) &
                        &               * b(nu, s_l(threadIdx%x), s_m(threadIdx%x))
                    enddo
    
                    xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) &
                      &               * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), ip, s_ls1(i)) &
                      &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), iq, s_ls2(i)) &
                      &               * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), ir, s_ls2(i)) &
                      &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), is, s_ls1(i))
                  enddo
                enddo
              enddo
            enddo
    
            xk1(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
          enddo
                              
          npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) + nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x))
          s_zpq(threadIdx%x) = (lmpqrs_array(j, 7) + lmpqrs_array(j, 9))*0.5_dp
          s_zrs(threadIdx%x) = (lmpqrs_array(j, 8) + lmpqrs_array(j, 10))*0.5_dp
          call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
          call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
          call auxc_gpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
          call auxc_gpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)
      
          do i = 1, 4
            xint(threadIdx%x) = 0.0_dp
            s_ntermp(threadIdx%x) = nterm(s_ls1(i), s_l(threadIdx%x))
            s_ntermq(threadIdx%x) = nterm(s_ls2(i), s_l(threadIdx%x))
            s_nterms(threadIdx%x) = nterm(s_ls2(i), s_m(threadIdx%x))
            s_ntermr(threadIdx%x) = nterm(s_ls1(i), s_m(threadIdx%x))
            do ip = 1, s_ntermp(threadIdx%x)
              do iq = 1, s_ntermq(threadIdx%x)
                do is = 1, s_nterms(threadIdx%x)
                  do ir = 1, s_ntermr(threadIdx%x)
                    npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(ir, s_ls1(i), s_m(threadIdx%x))
                    nrs(threadIdx%x) = nqntm(iq, s_ls2(i), s_l(threadIdx%x)) + nqntm(is, s_ls2(i), s_m(threadIdx%x))
      
                    term(threadIdx%x) = 0.0_dp
                    do nu = s_minnu(threadIdx%x), s_maxnu(threadIdx%x), 2
                      term(threadIdx%x) = term(threadIdx%x) + (v1(threadIdx%x, s_chan, npq(threadIdx%x) - nu -1) &
                        &             * v2(threadIdx%x, s_chan, nrs(threadIdx%x) + nu) * c1(threadIdx%x, s_chan, &
                        &             npq(threadIdx%x) - nu -1, nrs(threadIdx%x) + nu) + v2(threadIdx%x, s_chan, &
                        &             nrs(threadIdx%x) - nu -1) * v1(threadIdx%x, s_chan, npq(threadIdx%x) + nu) &
                        &             * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - nu -1, npq(threadIdx%x) + nu)) &
                        &             * b(nu, s_l(threadIdx%x), s_m(threadIdx%x))
                    enddo
    
                    xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) &
                      &               * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), ip, s_ls1(i)) &
                      &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), iq, s_ls2(i)) &
                      &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), is, s_ls2(i)) &
                      &               * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), ir, s_ls1(i))
                  enddo
                enddo
              enddo
            enddo
    
            xk2(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
          enddo
    
          xp(1, j) = xj(threadIdx%x, s_chan, 1) - 0.5_dp*(xk1(threadIdx%x, s_chan, 1) + xk2(threadIdx%x, s_chan, 1))
          xp(2, j) = xj(threadIdx%x, s_chan, 2)
          xp(3, j) = xj(threadIdx%x, s_chan, 3)
          xp(4, j) = -xk1(threadIdx%x, s_chan, 2)
          xp(5, j) = -xk2(threadIdx%x, s_chan, 2)
          xp(6, j) = -xk1(threadIdx%x, s_chan, 3)
          xp(7, j) = -xk2(threadIdx%x, s_chan, 3)
          xp(8, j) = xj(threadIdx%x, s_chan, 4) - 0.5_dp*(xk1(threadIdx%x, s_chan, 4) + xk2(threadIdx%x, s_chan, 4))
    
        enddo
    
        call syncthreads()
    
        !Always remember to release the channel
    
        if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
          call releasechannel(socket, s_chan)
        endif

      end subroutine eint2gpu

      attributes(global) subroutine vec2matrix_gpu(vector, matrix, n, locmx)
      ! Turns the vector
      ! v = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ....
      ! Into the matrix
      ! matrix = 1, 2, 4, 7, ...
      !          0, 3, 5, 8, ...
      !          0, 0, 6, 9, ...
      !          0, 0, 0, 10, ...
        implicit none
        real(dp), dimension(:)  ::  vector
        real(dp), dimension(:, :) ::  matrix
        integer ::  low, mid, high, i, p, q, lownum, highnum, n, lvec, locmx

        i = threadIdx%x + (blockIdx%x - 1) * blockDim%x
        lvec = ((n*2 - 1) * n * 2)/2 + (n * 2)

        if (i .le. lvec) then

        ! Compute column index q

          low = 1
          high = n*2 ! n is half the length of one dimension of the square matrix
          
          do while(low .le. high)
            mid = (high + low) / 2
            lownum = ((mid - 1) * mid)/2 + 1
            highnum = lownum + mid - 1
            if((i .ge. lownum) .and. (i .le. highnum)) then
              q = mid
              exit
            elseif(i .lt. lownum) then
              high = mid - 1
            elseif(i .gt. highnum) then
              low = mid + 1
            endif
          enddo
  
          ! Compute row index p
  
          p = i - lownum + 1
  
  
          ! Store vector in matrix
          
          matrix(p, q) = vector(i + locmx)

        endif

      end subroutine vec2matrix_gpu

      attributes(global) subroutine isqrtsmx_gpu(vec1, vec2, n)
        implicit none
        real(dp), dimension(:)  ::  vec1
        real(dp), dimension(:, :) ::  vec2
        integer ::  n, i
        real(dp)  ::  sqrti, isqrti

        i = threadIdx%x + (blockIdx%x - 1) * blockDim%x

        if(i .le. n*2) then
!          sqrti = dsqrt(vec1(i))
!          isqrti = 1.0_dp/sqrti
          sqrti = 1.0_dp/vec1(i)
          isqrti = dsqrt(sqrti)
          vec2(i, i) = isqrti ! not contiguous access, this can be improved
        endif

      end subroutine isqrtsmx_gpu

      attributes(global) subroutine formd_gpu(vectors, dtmx, domx, ocup, nos, locmx, nbs, i)
        implicit none
        real(dp), dimension(:, :) ::  vectors
        real(dp), shared, dimension(512, 7)   ::  s_vectors
        real(dp), dimension(:)  ::  dtmx, domx
        real(dp)  ::  total
        real(dp), dimension(:, :) ::  ocup
        integer, dimension(:, :) ::  nos
        integer, dimension(:) ::  locmx, nbs
        integer ::  i, k, n, r, s, p, q, low, high, lownum, highnum, mid

        n = nbs(i) * 2
        q = ((threadIdx%x - 1) / n) + 1
        p = mod(threadIdx%x - 1, n) + 1

        ! Closed Shells

        if((q .le. n) .and. (q .le. 7)) then
          s_vectors(p, q) = vectors(p, q + (n / 2))
        endif

        call syncthreads()

        if(threadIdx%x .le. ((n * (n - 1)) / 2) + n) then
          low = 1
          high = n

          do while(low .le. high)
            mid = (high + low) / 2
            lownum = ((mid - 1) * mid)/2 + 1
            highnum = lownum + mid - 1
            if((threadIdx%x .ge. lownum) .and. (threadIdx%x .le. highnum)) then
              r = mid
              exit
            elseif(threadIdx%x .lt. lownum) then
              high = mid - 1
            elseif(threadIdx%x .gt. highnum) then
              low = mid + 1
            endif
          enddo

          s = threadIdx%x - lownum + 1

          !You'll have to change this so it will loop over all occupied spinors

          total = 0.0_dp
          do k = 1, nos(1, i)
            total = total + s_vectors(r, k) * s_vectors(s, k)
          enddo
          total = total * ocup(1, i)

          dtmx(threadIdx%x) = total
        endif

      end subroutine formd_gpu










end module gpu_kernals
