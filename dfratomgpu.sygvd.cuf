module cpu_subroutines
  use datatypes
  use cudafor
  use cusolver_interfaces
  use cublas
  use iso_c_binding
  use gpu_kernals
  implicit none
  contains
    subroutine intin(iprvc, iprmx, intlvc, nft, nsym, maxbs, nucmdl, mtdpmx, nconf, maxitr,  &
      nbs, nos, alpha, rnuc, znuc, c, ixtrp, dfctr, thcvl, thcvs, thcven, thdll, thdsl, thdss,  &
      sym, ocupav, title, filenm)

      integer ::  l, p, i
      integer ::  iprvc, iprmx, intlvc, nft
      integer ::  nsym, maxbs, istat
      integer ::  nucmdl, mtdpmx, nconf, maxitr
      integer, allocatable, dimension(:)  ::  nbs
      integer, dimension(:, :) ::  nos
      real(dp)  ::  alpha, rnuc, znuc, c, ixtrp, dfctr
      real(dp)  ::  thcvl, thcvs, thcven, thdll, thdsl, thdss
      type(basisset), allocatable, dimension(:)  ::  sym
      real(dp), allocatable, dimension(:, :)  ::  ocupav
      character ::  title*200, filenm*200
      real(dp), parameter ::  cspeed = 137.03599976D0

      open(1, file = filenm, status = 'old')
      read(1, fmt='(a200)')title
      read(1, *)znuc, nucmdl, rnuc, alpha
      read(1, *)nsym, maxbs, mtdpmx, c

      allocate(nbs(nsym), stat = istat)
      if (istat /= 0) stop 'Error during allocation of nbs'
      allocate(sym(nsym), stat = istat)
      if (istat /= 0) stop 'Error during allocation of sym'

      if (nucmdl .eq. 0) then
        nucmdl = 2
      endif
      if (c .eq. 0.0d0) then
        c = cspeed
      endif
      if (mtdpmx .eq. 0) then
        mtdpmx = 1
      endif

      do l = 1, nsym
        read(1, *)nbs(l)
        allocate(sym(l)%zeta(nbs(l)), stat = istat)
        if (istat /= 0) stop 'Error during allocation of sym(l)%zeta'
        do p = 1, nbs(l)
          read(1, *)sym(l)%zeta(p)
        enddo
      enddo

      read(1, *)(nos(1, l), l = 1, nsym)
      read(1, *)(nos(2, l), l = 1, nsym)
      read(1, *)nconf

      allocate(ocupav(nsym, nconf), stat = istat)
      if (istat /= 0) stop 'Error during allocation of ocupav'

      if (nconf .ne. 0) then
        do i = 1, nconf
          read(1, *)(ocupav(l, i), l = 1, nsym)
        enddo
      endif

      read(1, *)maxitr, ixtrp, dfctr
      read(1, *)thcvl, thcvs, thcven, thdll, thdsl, thdss
      read(1, *)iprvc, iprmx, intlvc, nft

      if(iprvc .eq. 0)iprvc = 1
      if(intlvc .eq. 0)intlvc = 1

      close(1)

    end subroutine intin

    subroutine calc_parameters(nmx, nxp, nsym, maxbs, locmx, locxp, nbs, loctr, &
        nqntml, nterm, nqntm, coefb, numin, numax, nvc, locvc, vc, wav, vcc, ocup, ocupav, nconf, nos)

      integer ::  nmx, nxp, l, n, nsym, maxbs, istat, nvc, nbst, nconf, ncoef
      integer, dimension(:)  ::  locmx, locxp, nbs, locvc
      integer, allocatable, dimension(:)  ::  loctr
      integer, dimension(:, :)  ::  nos
      integer, dimension(7) ::  nqntml
      integer, dimension(2, 7)  ::  nterm
      integer, dimension(2, 2, 7) ::  nqntm
      real(dp), dimension(0:6, 7, 7)  ::  coefb
      integer, dimension(7, 7)  ::  numin, numax
      real(dp), allocatable, dimension(:)  ::  vc, wav
      real(dp), dimension(:, :)  ::  ocup, vcc
      real(dp), dimension(:, :)  ::  ocupav

      allocate(wav(nconf), stat = istat)
      if (istat /= 0) stop 'Error during allocation of wav'
      allocate(vc(maxbs ** 2), stat = istat)
      if (istat /= 0) stop 'Error during allocation of vc'

      nmx = 0
      nxp = 0

      do l = 1, nsym
        locmx(l) = nmx
        locxp(l) = nxp
        nmx = nmx + nbs(l) * (nbs(l) * 2 + 1)
        nxp = nxp + (nbs(l) * (nbs(l) + 1))/2
      enddo

      allocate(loctr(2 * maxbs), stat = istat)
      if (istat /= 0) stop 'Error during allocation of loctr'

      loctr(1) = 0

      do n = 1, maxbs * 2 - 1
        loctr(n + 1) = loctr(n) + n
      enddo

      do l = 1, nsym
        nterm(1, l) = 1
        nqntm(1, 1, l) = nqntml(l)
      enddo

      do l = 1, nsym, 2
        nterm(2, l) = 1
        nqntm(1, 2, l) = nqntml(l) + 1
      enddo

      do l = 2, nsym, 2
        nterm(2, l) = 2
        nqntm(1, 2, l) = nqntml(l) - 1
        nqntm(2, 2, l) = nqntml(l) + 1
      enddo
      
      call bcoef(coefb, numin, numax)

      nvc = 0
      do l = 1, nsym
        nos(3, l) = nos(1, l) + nos(2, l)
        locvc(l) = nvc
        nbst = nbs(l) * 2
        if (nos(3, l) .ne. 0) then
          nvc = nvc + nbst * nbst
        endif
      enddo

      call setvc(ocup, vcc, nsym, nos, nconf, wav, ocupav)

    end subroutine calc_parameters

    subroutine setvc(ocup , vcc, nsym, nos, nconf, wav, ocupav)
      real(dp), dimension(:, :) ::  ocup, vcc, ocupav
      real(dp), dimension(:)  ::  wav
      real(dp), dimension(7)  ::  ocupc
      real(dp)  ::  total, w, binom
      integer ::  i, l, m, nsym, nconf, nocup, locup
      integer, dimension(:, :) ::  nos
      data  ocupc/2 * 2.0d0, 2 * 4.0d0, 2*6.0d0, 8.0d0/

      if(nconf .ne. 0) then
        total = 0.0d0
        do i = 1, nconf
          w = 1.0d0
          do l = 1, nsym
            nocup = ocupc(l) + 0.0001
            locup = ocupav(l, i) + 0.0001
            w = w * binom(nocup, locup)
          enddo
          wav(i) = w

          total = total + wav(i)
        enddo

        do i = 1, nconf
          wav(i) = wav(i) / total
        enddo
      endif

      do l = 1, nsym
        nos(3, l) = nos(1, l) + nos(2, l)
        ocup(1, l) = 0.0d0
        ocup(2, l) = 0.0d0
        if (nos(1, l) .ne. 0) ocup(1, l) = ocupc(l)
        if (nconf .eq. 0) then
          continue
        else
          total = 0.0d0
          do i = 1, nconf
            total = total +wav(i) * ocupav(l, i)
          enddo
          ocup(2, l) = total
        endif
      enddo


      vcc = 0.0d0

      if(nconf .ne. 0) then
        do l = 1, nsym
          do m = 1, l
            if(nos(2, l) * nos(2, m) .ne. 0) then
              if (l .eq. m) then
                total = 0.0d0
                do i = 1, nconf
                  total = total + wav(i) * ocupav(l, i) * (ocupav(l, i) - 1.0d0)
                enddo
                total = total * ocupc(l) / (ocupc(l) - 1.0d0)
              else
                total = 0.0d0
                do i = 1, nconf
                  total = total + wav(i) * ocupav(l, i) * ocupav(m, i)
                enddo
              endif
              total = 1.0d0 - total / (ocup(2, l) * ocup(2, m))
              vcc(l, m) = total
              vcc(m, l) = total
            endif
          enddo
        enddo
      endif

    end subroutine setvc

    function binom(i, j)
      real(dp)  ::  binom
      real(dp), dimension(0:8)  ::  fctrl
      integer ::  i, j
      data  fctrl/2*1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0/

      binom = fctrl(i) / fctrl(j) / fctrl(i - j)
      return

    end function binom




    subroutine bcoef(coefb, numin, numax)
      real(dp), dimension(0:6, 7, 7)  ::  coefb
      integer, dimension(0:6, 10) ::  denom, numtr
      integer, dimension(:, :)  ::  numin, numax
      integer, dimension(7) ::  j2, lqntm 
      data  j2/1,1,3,3,5,5,7/, lqntm/0,1,1,2,2,3,3/
      data  numtr/1,1,5*0, 0,1,1,4*0, 3*1,9,3*0, 0,0,1,1,3*0, &
        0,1,1,2,2,0,0, 1,1,8,8,2,50,0, 3*0,1,1,0,0, &
        0,0,9,1,5,5,0, 0,3*1,5,5,25, 1,1,5,3,9,75,25/
      data  denom/1,3,5*0, 0,3,5,4*0, 2,30,10,70,3*0, 0,0,5,7,3*0,  &
        0,5,35,35,21,0,0, 3,105,105,315,63,693,0, 3*0,7,9,0,0,  &
        0,0,70,42,126,66,0, 0,7,105,21,231,231,429, &
        4,252,84,308,308,4004,1716/
      integer ::  l, l1, m, m1, lm, nu, minnu, maxnu

      do l = 1, 7
        l1 = (l - 1) / 2 + 1
        do m = 1, l
          m1 = (m - 1) / 2 + 1

          minnu = iabs(j2(l) - j2(m)) / 2
          maxnu = (j2(l) + j2(m)) / 2
          lm = lqntm(l) + lqntm(m)
          if (((lm / 2) * 2 .eq. lm) .and. ((minnu / 2) * 2 .ne. minnu)) then
            minnu = minnu + 1
          endif
          if (((lm / 2) * 2 .ne. lm) .and. ((minnu / 2) * 2 .eq. minnu)) then
            minnu = minnu + 1
          endif
          if (((minnu + maxnu) / 2) * 2 .ne. (minnu + maxnu)) then
            maxnu = maxnu - 1
          endif

          numin(l, m) = minnu
          numin(m, l) = minnu
          numax(l, m) = maxnu
          numax(m, l) = maxnu

          lm = (l1 * (l1 - 1)) / 2 + m1
          do nu = minnu, maxnu, 2
            coefb(nu, m, l) = 0.5d0 * dble(numtr(nu, lm)) / dble(denom(nu, lm))
            coefb(nu, l, m) = coefb(nu, m, l)
          enddo
        enddo
      enddo

    end subroutine bcoef

    subroutine bsnorm(cnorm, nsym, nbs, sym, maxbs, nqntml)
      real(dp), allocatable, dimension(:, :, :, :)  ::  cnorm
      type(basisset), dimension(:) ::  sym
      integer ::  nsym, maxbs, istat, l, p, n2
      integer, dimension(:) ::  nbs, nqntml
      real(dp), dimension(7) ::  bunsi, bumbo
      real(dp)  ::  v(0:10)
      data bunsi/0.D0, 6.D0,0.D0,10.D0,0.D0,14.D0,0.D0/
      data bumbo/0.D0,15.D0,0.D0,35.D0,0.D0,63.D0,0.D0/

      allocate(cnorm(maxbs, nsym, 2, 2), stat = istat)
      if (istat /= 0) stop 'Error during allocation of cnorm'

      do l = 1, nsym
        n2 = nqntml(l) * 2
        do p = 1, nbs(l)
          call auxv(n2 + 2, sym(l)%zeta(p), v)
! Large Component
          cnorm(p, l, 1, 1) = 1.0D0/dsqrt(v(n2))
! Small Component
          if(mod(l, 2) .eq. 0) then
            cnorm(p, l, 1, 2) = bunsi(l)/dsqrt(bumbo(l) * V(N2 - 2))
            cnorm(p, l, 2, 2) = -1.0d0/dsqrt(v(n2 + 2))
          else
            cnorm(p, l, 1, 2) = -1.0d0/dsqrt(v(n2 + 2))
          endif
        enddo
      enddo

    end subroutine bsnorm

    subroutine auxv(imax, x, v)
      real(dp), dimension(0:10) ::  v
      real(dp)  ::  x
      real(dp)  ::  x1
      integer ::  imax, imin, i

      x1 = 1.0d0/x
      if(mod(imax, 2) .eq. 0) then
        v(0) = dsqrt(x1)
        imin = 2
      else
        v(1) = x1
        imin = 3
      endif
      do i = imin, imax, 2
        v(i) = v(i - 2) * x1 * dble(i - 1)
      enddo

    end subroutine auxv


    subroutine lmpqrsa(nsym, sym, nbs, lmpqrs_array, lpq_array, i)
      implicit none

      integer ::  nsym, i, l, m, p, q, r, s, maxr, maxs, total
      integer, dimension(:) ::  nbs
      real(dp), dimension(:,:) ::  lmpqrs_array, lpq_array
      type(basisset), dimension(:) ::  sym

      i = 1

      do l = 1, nsym
        do p = 1, nbs(l)
          do q = 1, p
            do m = 1, l
              maxr = nbs(m)
              if (l .eq. m) maxr = p
              do r = 1, maxr
                maxs = r
                if ((l .eq. m) .and. (p .eq. r)) maxs = q
                do s = 1, maxs
                  lmpqrs_array(i,1) = l
                  lmpqrs_array(i,2) = m
                  lmpqrs_array(i,3) = p
                  lmpqrs_array(i,4) = q
                  lmpqrs_array(i,5) = r
                  lmpqrs_array(i,6) = s
                  lmpqrs_array(i,7) = sym(l)%zeta(p)
                  lmpqrs_array(i,8) = sym(l)%zeta(q)
                  lmpqrs_array(i,9) = sym(m)%zeta(r)
                  lmpqrs_array(i,10) = sym(m)%zeta(s)

                  i = i + 1
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
      i = 1
      do l = 1, nsym
        do p = 1, nbs(l)
          do q = 1, p
            lpq_array(i, 1) = sym(l)%zeta(p)
            lpq_array(i, 2) = sym(l)%zeta(q)
            lpq_array(i, 3) = l
            lpq_array(i, 4) = p
            lpq_array(i, 5) = q
            i = i + 1
          enddo
        enddo
      enddo
    end subroutine lmpqrsa

    subroutine guess(cusolver_hndl, cublas_hndl, d_smx, d_hmx,  &
      d_eigenvalsymm, d_eigenvecsymm, d_smxsymm, nbs, nsym, d_nbs, d_locmx)
      type(c_ptr) ::  cusolver_hndl
      type(cublasHandle)  ::  cublas_hndl
      type(cudaevent) ::  stopEvent
      integer, device, dimension(:) ::  d_nbs, d_locmx
      real(dp), device, dimension(:)  ::  d_smx, d_hmx
      real(dp), device, dimension(:), allocatable ::  d_work
      type(smxs), allocatable, dimension(:) ::  smxsymm
      type(d_smxs), allocatable, dimension(:) ::  d_smxsymm
      type(eigenvals), allocatable, dimension(:)  ::  eigenvalsymm
      type(d_eigenvals), allocatable, dimension(:)  ::  d_eigenvalsymm
      type(eigenvecs), allocatable, dimension(:)  ::  eigenvecsymm
      type(d_eigenvecs), allocatable, dimension(:)  ::  d_eigenvecsymm, d_tymp
      real(dp), dimension(:), allocatable ::  eigenval
      real(dp), dimension(:, :), allocatable  ::  eigenvec
      integer ::  n, i, k, nsym, lda
      integer(kind=cuda_count_kind) ::  free, total
      integer, dimension(:) ::  nbs
      integer ::  devinfo, istat, isync, lwork
      integer, device, target ::  d_devinfo
      type(c_devptr), device  ::  d_devinfo_ptr
      type(dim3)  ::  gridDim, blockDim
      integer ::  jobz, uplo
      character*30 ::  formt

      istat = cudaMemGetInfo(free, total)
      istat = cublasSetPointerMode(cublas_hndl, 0)
      write(6, *)'Free memory =',free, 'Total =', total

      blockDim = dim3(512, 1, 1)

      allocate(smxsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating smxsymm'
        stop
      endif
      allocate(d_smxsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_smxsymm'
        stop
      endif
      allocate(eigenvalsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating eigenvalsymm'
        stop
      endif
      allocate(eigenvecsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating eigenvecsymm'
        stop
      endif
      allocate(d_eigenvalsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_eigenvalsymm'
        stop
      endif
      allocate(d_eigenvecsymm(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_eigenvecsymm'
        stop
      endif
      allocate(d_tymp(nsym), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_eigenvecsymm'
        stop
      endif



      do i = 1, nsym    
        n = nbs(i) * 2
        gridDim = dim3(mod((n**2 + n)/2 + n, 512) + 1, 1, 1)
        write(formt, '("(",a, i0, "(g25.16",a,"), g25.16",a,")")')'"{"',n-1, '","','"},"'
        allocate(eigenvecsymm(i)%eigenvec(n, n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating eigenvec'
          stop
        endif
        allocate(d_eigenvecsymm(i)%d_eigenvec(n, n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating d_eigenvec'
          stop
        endif
        allocate(eigenvalsymm(i)%eigenval(n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating eigenval'
          stop
        endif
        allocate(d_eigenvalsymm(i)%d_eigenval(n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating d_eigenval'
          stop
        endif
        allocate(smxsymm(i)%isqrtsmx(n, n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating isqrtsmx'
          stop
        endif
        allocate(d_smxsymm(i)%d_isqrtsmx(n, n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating d_isqrtsmx'
          stop
        endif
        allocate(d_tymp(i)%d_eigenvec(n, n), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating d_isqrtsmx'
          stop
        endif
        d_devinfo_ptr = c_devloc(d_devinfo)
        d_eigenvecsymm(i)%d_eigenvec = 0.0_dp
        d_smxsymm(i)%d_isqrtsmx = 0.0_dp
      
        isync = cudaEventCreate(stopEvent)
        call vec2matrix_gpu <<<gridDim, blockDim>>> (d_smx, d_smxsymm(i)%d_isqrtsmx, d_nbs(i), d_locmx(i))
        call vec2matrix_gpu <<<gridDim, blockDim>>> (d_hmx, d_eigenvecsymm(i)%d_eigenvec, d_nbs(i), d_locmx(i))
        isync = cudaEventRecord(stopEvent,0)
        isync = cudaEventSynchronize(stopEvent)
        isync = cudaEventDestroy(stopEvent)

        ! Setting options for matrix diagonalization
      
        jobz = 1 ! We want both eigenvectors and eigenvalues
        uplo = 1 ! vec2matrix stores the matrix in the bottom half
        lda = n      
      
        isync = cudaEventCreate(stopEvent)
        istat = cusolverDnDsygvd_bufferSize(cusolver_hndl, 1, jobz, uplo, n, d_eigenvecsymm(i)%d_eigenvec, lda, &
          d_smxsymm(i)%d_isqrtsmx, lda, d_eigenvalsymm(i)%d_eigenval, lwork)
        isync = cudaEventRecord(stopEvent,0)
        isync = cudaEventSynchronize(stopEvent)
        isync = cudaEventDestroy(stopEvent)
        if (istat .ne. 0) then
          write(6, *)'cusolverDnDsyevd_bufferSize error: ', istat
          stop
        endif
      
        write(6,*)'Allocating ', 8*lwork, ' bytes of workspace'
      
        allocate(d_work(lwork), stat = istat)
        if(istat .ne. 0) then
          write(6, *)'Error allocating d_work'
        endif
        d_devinfo = 0
        isync = cudaEventCreate(stopEvent)
        istat = cusolverDnDsygvd(cusolver_hndl, 1, jobz, uplo, n, d_eigenvecsymm(i)%d_eigenvec, lda, &
          d_smxsymm(i)%d_isqrtsmx, lda, d_eigenvalsymm(i)%d_eigenval, d_work, lwork, d_devinfo_ptr)
        isync = cudaEventRecord(stopEvent,0)
        isync = cudaEventSynchronize(stopEvent)
        isync = cudaEventDestroy(stopEvent)
        devinfo = d_devinfo
        if ((istat .ne. 0) .or. (devinfo .ne. 0)) then
          devinfo = d_devinfo
          write(6, *)'cusolverDnDsyevd error: ', istat
          write(6,*)'devinfo: ', devinfo
          stop
        endif

        eigenvalsymm(i)%eigenval = d_eigenvalsymm(i)%d_eigenval
        eigenvecsymm(i)%eigenvec = d_eigenvecsymm(i)%d_eigenvec
        write(6, *)'Eigenvals'
        do k = 1, n
          write(6, formt)eigenvalsymm(i)%eigenval(k)
        enddo
        write(6, *)'Eigenvecs'
        do k = 1, n
          write(6, formt)eigenvecsymm(i)%eigenvec(k, 1:n)
        enddo
        
      enddo
      do i = 1, nsym
        deallocate(d_tymp(i)%d_eigenvec, stat = istat)
        if (istat .ne. 0) then
          write(6, fmt='(a,i0,a)')'Error deallocating d_tymp(',i,')%d_eigenvec'
          stop
        endif
      enddo
      deallocate(d_tymp, stat = istat)
      if (istat .ne. 0) then
        write(6, *)'Error deallocating d_tymp'
        stop
      endif

    end subroutine guess

    subroutine scfiter(cusolver_hndl, cublas_hndl, d_eigenvalsymm, d_eigenvecsymm,  &
      d_smxsymm, nmx, d_nbs, d_locmx, nsym, nos, ocup)
      implicit none

      type(c_ptr) ::  cusolver_hndl
      type(cublasHandle)  ::  cublas_hndl
      type(d_smxs), allocatable, dimension(:) ::  d_smxsymm
      type(d_eigenvals), dimension(:)  ::  d_eigenvalsymm
      type(d_eigenvecs), dimension(:)  ::  d_eigenvecsymm
      integer, device, dimension(:) ::  d_nbs, d_locmx
      integer, device, dimension(3, 7)  ::  d_nos
      integer, device ::  d_i
      real(dp), device, dimension(2, 7) ::  d_ocup
      real(dp), device, allocatable, dimension(:) ::  d_dtmx, d_domx
      real(dp), allocatable, dimension(:) ::  dtmx, domx
      integer ::  nmx, nsym, istat, i
      integer, dimension(:, :)  ::  nos
      real(dp), dimension(:, :) ::  ocup
      type(dim3)  ::  gridDim, blockDim

      blockDim = dim3(512, 1, 1)
      gridDim = dim3(1, 1, 1)

      allocate(dtmx(nmx), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating dtmx'
        stop
      endif
      allocate(domx(nmx), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating domx'
        stop
      endif
      allocate(d_dtmx(nmx), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_dtmx'
        stop
      endif
      allocate(d_domx(nmx), stat = istat)
      if(istat .ne. 0) then
        write(6, *)'Error allocating d_domx'
        stop
      endif

      write(6,*)nmx,'aaaa'

      d_dtmx = 0.0_dp
      d_nos = nos
      d_ocup = ocup

      do i = 1, 1
        d_i = i
        call formd_gpu <<<gridDim, blockDim>>> (d_eigenvecsymm(i)%d_eigenvec, &
          d_dtmx, d_domx, d_ocup, d_nos, d_locmx, d_nbs, d_i)
      enddo

      dtmx = d_dtmx
      write(6, *)'dtmx'
      write(6, *)dtmx


      



    end subroutine scfiter



end module cpu_subroutines

program dfratom
  use gpu_kernals
  use cpu_subroutines
  use datatypes
  use cudafor
  use cusolver_interfaces
  use cublas
  use iso_c_binding
  implicit none

  integer ::  iprvc, iprmx, intlvc, nft, nvc, i, total, total2, j, k, l, p, q
  integer ::  nsym, maxbs, istat, isync, lpq
  integer ::  nucmdl, mtdpmx, nconf, maxitr
  integer, allocatable, dimension(:)  ::  nbs
  integer, dimension(3, 7) ::  nos
  real(dp)  ::  alpha, rnuc, znuc, c, ixtrp, dfctr
  real(dp)  ::  thcvl, thcvs, thcven, thdll, thdsl, thdss
  type(basisset), allocatable, dimension(:) ::  sym
  real(dp), allocatable, dimension(:, :)  ::  ocupav
  real(dp), allocatable, dimension(:)  ::  vc, wav
  real(dp), dimension(7, 7) ::  vcc
  real(dp), dimension(2, 7)  ::  ocup
  real(dp), allocatable, dimension(:, :, :, :)  ::  cnorm
  integer ::  nmx, nxp, ierr, num_sm, top_lpqll
  integer, dimension(7)  ::  locmx, locxp, locvc
  integer, allocatable, dimension(:)  ::  loctr
  integer, dimension(7) ::  nqntml
  data  nqntml/1,2,2,3,3,4,4/
  integer, dimension(2, 7)  ::  nterm
  integer, dimension(2, 2, 7) ::  nqntm
  real(dp), dimension(0:6, 7, 7)  ::  coefb
  integer, dimension(7, 7)  ::  numin, numax
  character ::  title*200, filenm*200
  type(dim3)  ::  gridDim, blockDim
  type(cudadeviceprop)  ::  prop
  type(cudaEvent) ::  startEvent, stopEvent
  integer ::  maxthreadx, maxthready, maxthreadz, loc, occ
  real(dp), allocatable, dimension(:) ::  hmx, smx
  real(dp), device, allocatable, dimension(:) ::  d_hmx, d_smx
  real(dp), device, allocatable, dimension(:, :) ::  d_xints, d_xintus
  integer, device, allocatable, dimension(:)  ::  d_locxp, d_loctr, d_locmx, d_nbs
  integer, device ::  d_nsym, d_maxbs, d_nucmdl, d_num_sm, d_total, d_total2
  real(dp), device  ::  d_c, d_alpha, d_znuc, d_rnuc
  real(dp), device, allocatable, dimension(:, :, :) ::  d_v1, d_v2
  real(dp), device, allocatable, dimension(:, :, :, :)  ::  d_cnorm, d_c1, d_c2
  integer, device, allocatable, dimension(:)  ::  d_socket
  integer, device, allocatable, dimension(:, :) ::  d_nterm
  integer, device, allocatable, dimension(:, :, :)  ::  d_nqntm
  real(dp), allocatable, dimension(:, :)  ::  lpq_array
  real(dp), allocatable, dimension(:, :)  ::  lmpqrs_array
  real(dp), device, allocatable, dimension(:, :)  ::  d_lpq_array
  real(dp), device, allocatable, dimension(:, :)  ::  d_lmpqrs_array
  real(dp), allocatable, dimension(:, :, :) ::  v1, v2
  real(dp), allocatable, dimension(:, :, :, :)  ::  c1, c2
  real(dp), dimension(512,2)  ::  xu
  real(dp), device, dimension(512,2)  ::  d_xu
  real(dp), dimension(512, 14)  :: xints
  real(dp), device, dimension(0:6, 7, 7)  ::  d_coefb
  real(dp), allocatable, dimension(:, :)  ::  xp
  integer, device, dimension(7, 7)  ::  d_numin, d_numax
  real(dp), device, allocatable, dimension(:, :)  ::  d_xp
  real(dp), device, allocatable, dimension(:, :, :)  ::  d_xj, d_xk1, d_xk2
  integer, device, dimension(4) ::  d_ls1, d_ls2
  type(d_smxs), allocatable, dimension(:) ::  d_smxsymm

  ! Variables for using cuBLAS
  type(cublasHandle)  ::  cublas_hndl
  ! Variables for using cuSOLVER

  type(d_eigenvecs), allocatable, dimension(:)  ::  d_eigenvecsymm
  type(d_eigenvals), allocatable, dimension(:) ::  d_eigenvalsymm
  type(c_ptr) ::  cusolver_hndl

  ! Load the cusolverDn library

  write(6,*)'Initializing cublas library'
  istat = cublasCreate(cublas_hndl)
  if (istat .ne. 0) then
    write(6, *)'cublascreate error: ', istat
    stop
  endif
  write(6,*)'Initializing cusolverDn library'
  istat = cusolverDnCreate(cusolver_hndl)
  if (istat .ne. 0) then
    write(6, *)'cusolverDnCreate error: ', istat
    stop
  endif

  call getarg(1, filenm)

  call intin(iprvc, iprmx, intlvc, nft, nsym, maxbs, nucmdl, mtdpmx, nconf, maxitr,  &
     nbs, nos, alpha, rnuc, znuc, c, ixtrp, dfctr, thcvl, thcvs, thcven, thdll, thdsl, thdss,  &
     sym, ocupav, title, filenm)

  call calc_parameters(nmx, nxp, nsym, maxbs, locmx, locxp, nbs, loctr, &
     nqntml, nterm, nqntm, coefb, numin, numax, nvc, locvc, vc, wav, vcc, ocup, ocupav, nconf, nos)

  call bsnorm(cnorm, nsym, nbs, sym, maxbs, nqntml)


! not needed if not using contracted basis sets, therefore I have not actually
! writen this subroutine
!  call normbs(nsym, nbs, zeta, nterm, nqntm, cnorm)

! setting up gpu arrays and transfering data for 1 and 2 eints

  ierr = 0
  ! occ is the max blocks per sm for this kernal as determined by the CUDA
  ! Occupancy Spreadsheet
  ! http://developer.download.nvidia.com/compute/cuda/CUDA_Occupancy_calculator.xls link as of March 27, 2017

  occ = 1

  istat = cudaGetDeviceProperties(prop, 0)
  num_sm = prop%multiProcessorCount*occ

  maxthreadx = 512
  maxthready = 1
  maxthreadz = 1

  blockDim = dim3(maxthreadx,maxthready,maxthreadz)
  gridDim = dim3(num_sm, 1, 1)


  total = 0

  do i = 1, nsym
    total = total + (nbs(i)/2.0_dp*(1+nbs(i)))
  enddo

  lpq = locxp(nsym) + loctr(nbs(nsym)) + nbs(nsym)

  total2 = ((lpq - 1) * lpq) / 2 + lpq

  allocate(lpq_array(total,5), stat = istat)
  if (istat /= 0) stop 'Error during allocation of lpqarray'
  allocate(lmpqrs_array(total2, 10), stat = istat)
  if (istat /= 0) stop 'Error during allocation of lmpqrs_array'

  call lmpqrsa(nsym, sym, nbs, lmpqrs_array, lpq_array, total)

  total = total - 1

  top_lpqll = locmx(nsym) + loctr(nbs(nsym) * 2) + (nbs(nsym) * 2)

  ! Allocating CPU memory, some of this is debugging
  allocate(smx(top_lpqll), stat = istat)
  if (istat /= 0) stop 'Error during allocation of smx'
  allocate(hmx(top_lpqll), stat = istat)
  if (istat /= 0) stop 'Error during allocation of hmx'
  allocate(xp(8, total2), stat = istat)
  if (istat /= 0) stop 'Error during allocation of xp'
  allocate(v1(maxthreadx, num_sm, 0:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of v1'
  allocate(v2(maxthreadx, num_sm, 0:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of v2'
  allocate(c1(maxthreadx, num_sm, 9, 2:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of c1'
  allocate(c2(maxthreadx, num_sm, 9, 2:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of c2'
  ! Allocating GPU memory
  allocate(d_smx(top_lpqll), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_smx'
  allocate(d_nbs(nsym), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_nbs'
  allocate(d_hmx(top_lpqll), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_hmx'
  allocate(d_xp(8, total2), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xp'
  allocate(d_xj(maxthreadx, num_sm, 4), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xj'
  allocate(d_xk1(maxthreadx, num_sm, 4), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xk1'
  allocate(d_xk2(maxthreadx, num_sm, 4), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xk2'
  allocate(d_v1(maxthreadx, num_sm, 0:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_v1'
  allocate(d_v2(maxthreadx, num_sm, 0:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_v2'
  allocate(d_c1(maxthreadx, num_sm, 9, 2:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_c1'
  allocate(d_c2(maxthreadx, num_sm, 9, 2:20), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_c2'
  allocate(d_nterm(size(nterm, 1), size(nterm, 2)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_nterm'
  allocate(d_nqntm(size(nqntm, 1), size(nqntm, 2), size(nqntm, 3)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_nqntm'
  allocate(d_cnorm(size(cnorm, 1), size(cnorm, 2), size(cnorm, 3), size(cnorm, 4)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_cnorm'
  allocate(d_locmx(size(locmx)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_locmx'
  allocate(d_locxp(size(locxp)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_locxp'
  allocate(d_loctr(size(loctr)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_loctr'
  allocate(d_lpq_array(total, 5), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_lpq_array'
  allocate(d_lmpqrs_array(total2, 10), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_lmpqrs_array'
  allocate(d_socket(num_sm), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_socket'
  allocate(d_xints(maxthreadx, num_sm), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xints'
  allocate(d_xintus(maxthreadx, num_sm), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xintus'


  d_nsym = nsym
  d_nbs = nbs
  d_maxbs = maxbs
  d_nterm = nterm
  d_nqntm = nqntm
  d_cnorm = cnorm
  d_znuc = znuc
  d_rnuc = rnuc
  d_alpha = alpha
  d_nucmdl = nucmdl
  d_c = c
  d_c1 = 0.0d0
  d_c2 = 0.0d0
  d_locmx = locmx
  d_loctr = loctr
  d_lpq_array = lpq_array
  d_num_sm = num_sm
  d_socket = 0
  d_v1 = 0.0d0
  d_v2 = 0.0d0
  d_xu = 0.0d0
  d_xints = 0.0d0
  d_smx = 0.0d0
  d_hmx = 0.0d0
  d_total = total
  d_total2 = total2
  d_ls1 = (/1, 1, 2, 2/)
  d_ls2 = (/1, 2, 1, 2/)
  d_lmpqrs_array = lmpqrs_array
  d_numin = numin
  d_numax = numax
  d_locxp = locxp
  d_coefb = coefb
  d_xp = 0.0d0

  write(6, *)sizeof(xp)


  isync = cudaEventCreate(stopEvent)


  call eint1gpu <<<gridDim, blockDim>>> (d_smx, d_hmx, d_nsym, d_nbs, d_maxbs,  &
    d_nterm, d_nqntm, d_cnorm, d_znuc, d_rnuc, d_alpha, d_nucmdl, d_c, d_locmx, &
    d_loctr, d_lpq_array, d_v1, d_c1, d_c2, d_num_sm, d_socket, d_xints, d_xintus, d_total)

  ! Making sure the async issues dont happen, I plan to implement async
  ! computaion of the integrals eventually 
  isync = cudaEventRecord(stopEvent,0)
  isync = cudaEventSynchronize(stopEvent)
  isync = cudaEventDestroy(stopEvent)
  isync = cudaEventCreate(stopEvent)

  d_socket = 0

  call eint2gpu <<<gridDim, blockDim >>> (d_xp, d_nsym, d_nbs, d_nterm,  &
    d_nqntm, d_cnorm, d_coefb, d_numin, d_numax, d_locxp, d_loctr, d_maxbs, d_v1, d_v2, d_c1, &
    d_c2, d_xj, d_xk1, d_xk2, d_ls1, d_ls2, d_socket, d_num_sm, d_lmpqrs_array,  &
    d_total2)

  isync = cudaEventRecord(stopEvent,0)
  isync = cudaEventSynchronize(stopEvent)
  isync = cudaEventDestroy(stopEvent)
  
  ! Computing the guess

  isync = cudaEventCreate(stopEvent)
  call guess(cusolver_hndl, cublas_hndl, d_smx, d_hmx,  &
    d_eigenvalsymm, d_eigenvecsymm, d_smxsymm, nbs, nsym, d_nbs, d_locmx)
  isync = cudaEventRecord(stopEvent,0)
  isync = cudaEventSynchronize(stopEvent)
  isync = cudaEventDestroy(stopEvent)
  
  isync = cudaEventCreate(stopEvent)
!  call scfiter(cusolver_hndl, cublas_hndl, d_eigenvalsymm, d_eigenvecsymm,  &
!    d_smxsymm, nmx, d_nbs, d_locmx, nsym, nos, ocup)
  isync = cudaEventRecord(stopEvent,0)
  isync = cudaEventSynchronize(stopEvent)
  isync = cudaEventDestroy(stopEvent)
 
  ! Deallocating device memory and libraries

  deallocate(d_lpq_array, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_lpq_array'

  
  deallocate(d_smx, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_smx'
  deallocate(d_nbs, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_nbs'
  deallocate(d_hmx, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_hmx'
  deallocate(d_v1, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_v1'
  deallocate(d_v2, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_v2'
  deallocate(d_c1, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_c1'
  deallocate(d_c2, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_c2'
  deallocate(d_nterm, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_nterm'
  deallocate(d_nqntm, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_nqntm'
  deallocate(d_cnorm, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_cnorm'
  deallocate(d_locmx, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_locmx'
  deallocate(d_loctr, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_loctr'
  deallocate(d_lpq_array, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_lpq_array'
  deallocate(d_socket, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_socket'
  deallocate(d_xints, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_xints'
  deallocate(d_xintus, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_xintus'

  istat = cublasDestroy(cublas_hndl)
  if (istat .ne. 0) then
    write(6, *)'cublasDestroy error: ', istat
    stop
  endif
  istat = cusolverDnDestroy(cusolver_hndl)
  if (istat .ne. 0) then
    write(6, *)'cusolverDnDestroy error: ', istat
    stop
  endif



end program dfratom




