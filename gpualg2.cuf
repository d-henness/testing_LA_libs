module gpu_algorithm
  contains
  attributes(device) subroutine findchannel(socket, num_sm, s_found, s_chan, i)
    implicit none
    integer ::  i, istat
    integer ::  num_sm
    integer ::  s_chan
    integer, dimension(:) ::  socket
    logical ::  s_found
    integer ::  s_plug

    s_chan = 0
    s_found = .false.

    i = 1
    do while (s_found .eqv. .false.)
      s_plug = atomicadd(socket(i), 1)
      if (s_plug .eq. 0) then
        s_chan = i
        s_found = .true.
      elseif(s_plug .gt. 0) then
        istat = atomicsub(socket(i), 1)
        i = i + 1
        if (i .gt. num_sm) then
          i = 1
        endif
      endif
    enddo

  end subroutine findchannel

  attributes(device) subroutine releasechannel(socket, s_chan)
    implicit none
    integer, dimension(:) ::  socket
    integer ::  s_chan, istat

    istat = atomicsub(socket(s_chan), 1)

  end subroutine releasechannel    

  attributes(device) subroutine auxv1gpu(imax, x, v, s, s_chan)
    implicit none
    integer, intent(in) ::  imax, s, s_chan
    integer ::  i
    real(kind = 8), intent(in)  ::  x
    real(kind = 8)  ::  x1
    real(kind = 8),intent(out), dimension(:, :, 0:)  ::  v

    x1 = 1.0d0/x
    v(s, s_chan, 0) = dsqrt(x1)
    v(s, s_chan, 1) = x1

    do i = 2, imax, 2
      v(s, s_chan, i) = v(s, s_chan, i - 2) * x1 * real(i - 1, 8)
    enddo
    do i = 3, imax, 2
      v(s, s_chan, i) = v(s, s_chan, i - 2) * x1 * real(i - 1, 8)
    enddo
  end subroutine auxv1gpu

  attributes(device) subroutine auxcgpu(maxa, maxb, t, c, s, s_chan)
    implicit none
    integer ::  i, j
    integer, intent(in) ::  maxa, maxb, s, s_chan
    real(kind = 8), intent(in)  ::  t
    real(kind = 8), intent(out), dimension(:, :, :, 2:) ::  c
    real(kind = 8)  ::  t1, t2, d

    t1 = 1.0d0/(1.0d0 + t)
    t2 = t1 * t

    c(s, s_chan, 1, 2) = t1 * dsqrt(t1)

    if (maxa .gt. 1) then
      d = c(s, s_chan, 1, 2)
      do i = 3, maxa, 2
        d = d * t2 * real(i, 8)/real(i - 1, 8)
        c(s, s_chan, i, 2) = c(s, s_chan, i - 2, 2) +d
      enddo
    endif

    do j = 4, maxb, 2
      c(s, s_chan, 1, j) = c(s, s_chan, 1, j - 2) * t1
    enddo

    do j = 4, maxb, 2
      do i = 3, maxa, 2
        c(s, s_chan, i, j) = c(s, s_chan, i, j -2) * t1 + c(s, s_chan, i -2, j) * t2
      enddo
    enddo

  end subroutine auxcgpu

  attributes(global) subroutine algorithm_test_kernel(xp, nsym, nbs, zeta, nterm, nqntm, cnorm, b, numin, numax, locxp, loctr, maxnbs, v1, v2, c1, c2, xj, xk1, xk2, ls1, ls2, socket, num_sm, lmpqrsarray, sizemax)
    implicit none
    
    integer, dimension(:) ::  socket 
    logical, shared ::  s_found
    integer, shared ::  s_chan, s_plug
    integer ::  nsym, maxnbs, num_sm, sizemax
    integer,dimension(nsym) ::  nbs
    integer ::  i, j, nu, istat
    real(kind = 8), dimension(512, 14, 4)  ::  xj, xk1, xk2 
    integer, shared, dimension(512) ::  npq, nrs 
    integer ::  nterm1, nterm2 
    integer ::  ip, iq, ir, is
    integer, dimension(:, :, :) ::  nqntm
    real(kind = 8), shared, dimension(512)  ::  s_zpq, s_zrs
    real(kind = 8), shared, dimension(512)  ::  xint, term
    real(kind = 8), dimension(:, :) ::  zeta
    real(kind = 8), dimension(0:6, 7, 7)  ::  b
    integer, shared, dimension(512)  ::  s_ntermp, s_ntermq, s_nterms, s_ntermr
    integer, shared, dimension(512) ::  s_minnu, s_maxnu
    integer, dimension(7, 7) ::  numin, numax
    integer, dimension(2, 7)  ::  nterm
    real(kind = 8), dimension(512, 14, 0:20)  ::  v1, v2     
    real(kind = 8), dimension(512, 14, 9, 2:20)  ::  c1, c2  
    integer, dimension(4)  ::  ls1, ls2 
    integer, shared, dimension(4) ::  s_ls1, s_ls2
    real(kind = 8), dimension(:, :, :, :) ::  cnorm
    real(kind = 8), parameter ::  xfctr = 1.595769121605731D0
    integer, dimension(:)  ::  locxp, loctr
    real(kind = 8), dimension(:, :) ::  xp 
    integer, dimension(sizemax, 6) ::  lmpqrsarray
    integer, shared, dimension(512) ::  s_l, s_m, s_p, s_q, s_r, s_s


    ! In order to prevent race condition bugs, a "channel" needs to be selected.
    ! findchannel and release channel work by looping over 1 to the number of
    ! SMs over and over until it finds one that is free. Note that with the way
    ! this is currently written, the occupancy must be known and set before
    ! hand.


    if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
      call findchannel(socket, num_sm, s_found, s_chan, i)
    endif

    call syncthreads()

    if ((threadIdx%x .gt. 0) .and. (threadIdx%x .lt. 5)) then
      s_ls1(threadIdx%x) = ls1(threadIdx%x)
      s_ls2(threadIdx%x) = ls2(threadIdx%x)
    endif

    call syncthreads()

    do j = ((blockIdx%x - 1) * blockDim%x) + threadIdx%x, sizemax, blockDim%x*gridDim%x

      s_l(threadIdx%x) = lmpqrsarray(j, 1)
      s_m(threadIdx%x) = lmpqrsarray(j, 2)
      s_p(threadIdx%x) = lmpqrsarray(j, 3)
      s_q(threadIdx%x) = lmpqrsarray(j, 4)
      s_r(threadIdx%x) = lmpqrsarray(j, 5)
      s_s(threadIdx%x) = lmpqrsarray(j, 6)

      do i = 1, 4
        xj(threadIdx%x, s_chan, i) = 0.0d0
        xk1(threadIdx%x, s_chan, i) = 0.0d0
        xk2(threadIdx%x, s_chan, i) = 0.0d0
      enddo

      npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) * 2
      nrs(threadIdx%x) = nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x)) * 2
      s_zpq(threadIdx%x) = (zeta(s_p(threadIdx%x), s_l(threadIdx%x)) + zeta(s_q(threadIdx%x), s_l(threadIdx%x))) * 0.5d0
      s_zrs(threadIdx%x) = (zeta(s_r(threadIdx%x), s_m(threadIdx%x)) + zeta(s_s(threadIdx%x), s_m(threadIdx%x))) * 0.5d0

      call auxV1gpu(npq(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
      call auxV1gpu(nrs(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
      call auxCgpu(npq(threadIdx%x) - 1, nrs(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
      call auxCgpu(nrs(threadIdx%x) - 1, npq(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)

      do i = 1, 4
!                      s_ls1(i) = ls1(i)
!                      s_ls2(i) = ls2(i)

        xint(threadIdx%x) = 0.0d0
        nterm1 = nterm(s_ls1(i), s_l(threadIdx%x))
        nterm2 = nterm(s_ls2(i), s_m(threadIdx%x))

        do ip = 1, nterm1
          do iq = 1, nterm1
            do ir = 1, nterm2
              do is = 1, nterm2
                npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(iq, s_ls1(i), s_l(threadIdx%x))
                nrs(threadIdx%x) = nqntm(ir, s_ls2(i), s_m(threadIdx%x)) + nqntm(is, s_ls2(i), s_m(threadIdx%x))

                term(threadIdx%x) = (v1(threadIdx%x, s_chan, npq(threadIdx%x) - 1) * v2(threadIdx%x, s_chan, nrs(threadIdx%x)) &
                  &               * c1(threadIdx%x, s_chan, npq(threadIdx%x) - 1, nrs(threadIdx%x)) + v2(threadIdx%x, s_chan, nrs(threadIdx%x) - 1) &
                  &               * v1(threadIdx%x, s_chan, npq(threadIdx%x)) * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - 1, npq(threadIdx%x)))  
                xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), s_ls1(i), ip) &
                  &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), s_ls1(i), iq) * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), s_ls2(i), ir) &
                  &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), s_ls2(i), is)
              enddo
            enddo
          enddo
        enddo

        xj(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
      enddo

      s_minnu(threadIdx%x) = numin(s_l(threadIdx%x), s_m(threadIdx%x))
      s_maxnu(threadIdx%x) = numax(s_l(threadIdx%x), s_m(threadIdx%x))
      npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) + nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x))
      s_zpq(threadIdx%x) = (zeta(s_p(threadIdx%x), s_l(threadIdx%x)) + zeta(s_s(threadIdx%x), s_m(threadIdx%x)))*0.5d0
      s_zrs(threadIdx%x) = (zeta(s_q(threadIdx%x), s_l(threadIdx%x)) + zeta(s_r(threadIdx%x), s_m(threadIdx%x)))*0.5d0
      call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
      call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
      call auxcgpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
      call auxcgpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)

      do i = 1, 4
        xint(threadIdx%x) = 0.0d0
        s_ntermp(threadIdx%x) = nterm(s_ls1(i), s_l(threadIdx%x))
        s_ntermq(threadIdx%x) = nterm(s_ls2(i), s_l(threadIdx%x))
        s_ntermr(threadIdx%x) = nterm(s_ls2(i), s_m(threadIdx%x))
        s_nterms(threadIdx%x) = nterm(s_ls1(i), s_m(threadIdx%x))
        do ip = 1, s_ntermp(threadIdx%x)
          do iq = 1, s_ntermq(threadIdx%x)
            do ir = 1, s_ntermr(threadIdx%x)
              do is = 1, s_nterms(threadIdx%x)
                npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(is, s_ls1(i), s_m(threadIdx%x))
                nrs(threadIdx%x) = nqntm(iq, s_ls2(i), s_l(threadIdx%x)) + nqntm(ir, s_ls2(i), s_m(threadIdx%x))

                term(threadIdx%x) = 0.0d0
                do nu = s_minnu(threadIdx%x), s_maxnu(threadIdx%x), 2
                  term(threadIdx%x) = term(threadIdx%x) + (v1(threadIdx%x, s_chan, npq(threadIdx%x) - nu -1) &
                    &               * v2(threadIdx%x, s_chan, nrs(threadIdx%x) + nu) * c1(threadIdx%x, s_chan, &
                    &                 npq(threadIdx%x) - nu -1, nrs(threadIdx%x) + nu) + v2(threadIdx%x, s_chan, &
                    &                 nrs(threadIdx%x) - nu -1) * v1(threadIdx%x, s_chan, npq(threadIdx%x) + nu) &
                    &               * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - nu -1, npq(threadIdx%x) + nu)) &
                    &               * b(nu, s_l(threadIdx%x), s_m(threadIdx%x))
                enddo

                xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) &
                  &               * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), s_ls1(i), ip) &
                  &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), s_ls2(i), iq) &
                  &               * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), s_ls2(i), ir) &
                  &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), s_ls1(i), is)
              enddo
            enddo
          enddo
        enddo

        xk1(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
      enddo
                          
      npq(threadIdx%x) = nqntm(nterm(2, s_l(threadIdx%x)), 2, s_l(threadIdx%x)) + nqntm(nterm(2, s_m(threadIdx%x)), 2, s_m(threadIdx%x))
      s_zpq(threadIdx%x) = (zeta(s_p(threadIdx%x), s_l(threadIdx%x)) + zeta(s_r(threadIdx%x), s_m(threadIdx%x)))*0.5d0
      s_zrs(threadIdx%x) = (zeta(s_q(threadIdx%x), s_l(threadIdx%x)) + zeta(s_s(threadIdx%x), s_m(threadIdx%x)))*0.5d0
      call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x), v1, threadIdx%x, s_chan)
      call auxv1gpu(npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x), v2, threadIdx%x, s_chan)
      call auxcgpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zpq(threadIdx%x)/s_zrs(threadIdx%x), c1, threadIdx%x, s_chan)
      call auxcgpu(npq(threadIdx%x) - 1, npq(threadIdx%x) + s_maxnu(threadIdx%x), s_zrs(threadIdx%x)/s_zpq(threadIdx%x), c2, threadIdx%x, s_chan)
  
      do i = 1, 4
        xint(threadIdx%x) = 0.0d0
        s_ntermp(threadIdx%x) = nterm(s_ls1(i), s_l(threadIdx%x))
        s_ntermq(threadIdx%x) = nterm(s_ls2(i), s_l(threadIdx%x))
        s_nterms(threadIdx%x) = nterm(s_ls2(i), s_m(threadIdx%x))
        s_ntermr(threadIdx%x) = nterm(s_ls1(i), s_m(threadIdx%x))
        do ip = 1, s_ntermp(threadIdx%x)
          do iq = 1, s_ntermq(threadIdx%x)
            do is = 1, s_nterms(threadIdx%x)
              do ir = 1, s_ntermr(threadIdx%x)
                npq(threadIdx%x) = nqntm(ip, s_ls1(i), s_l(threadIdx%x)) + nqntm(ir, s_ls1(i), s_m(threadIdx%x))
                nrs(threadIdx%x) = nqntm(iq, s_ls2(i), s_l(threadIdx%x)) + nqntm(is, s_ls2(i), s_m(threadIdx%x))
  
                term(threadIdx%x) = 0.0d0
                do nu = s_minnu(threadIdx%x), s_maxnu(threadIdx%x), 2
                  term(threadIdx%x) = term(threadIdx%x) + (v1(threadIdx%x, s_chan, npq(threadIdx%x) - nu -1) &
                    &             * v2(threadIdx%x, s_chan, nrs(threadIdx%x) + nu) * c1(threadIdx%x, s_chan, &
                    &             npq(threadIdx%x) - nu -1, nrs(threadIdx%x) + nu) + v2(threadIdx%x, s_chan, &
                    &             nrs(threadIdx%x) - nu -1) * v1(threadIdx%x, s_chan, npq(threadIdx%x) + nu) &
                    &             * c2(threadIdx%x, s_chan, nrs(threadIdx%x) - nu -1, npq(threadIdx%x) + nu)) &
                    &             * b(nu, s_l(threadIdx%x), s_m(threadIdx%x))
                enddo

                xint(threadIdx%x) = xint(threadIdx%x) + term(threadIdx%x) &
                  &               * cnorm(s_p(threadIdx%x), s_l(threadIdx%x), s_ls1(i), ip) &
                  &               * cnorm(s_q(threadIdx%x), s_l(threadIdx%x), s_ls2(i), iq) &
                  &               * cnorm(s_s(threadIdx%x), s_m(threadIdx%x), s_ls2(i), is) &
                  &               * cnorm(s_r(threadIdx%x), s_m(threadIdx%x), s_ls1(i), ir)
              enddo
            enddo
          enddo
        enddo

        xk2(threadIdx%x, s_chan, i) = xint(threadIdx%x) * xfctr
      enddo

      xp(1, j) = xj(threadIdx%x, s_chan, 1) - 0.5d0*(xk1(threadIdx%x, s_chan, 1) + xk2(threadIdx%x, s_chan, 1))
      xp(2, j) = xj(threadIdx%x, s_chan, 2)
      xp(3, j) = xj(threadIdx%x, s_chan, 3)
      xp(4, j) = -xk1(threadIdx%x, s_chan, 2)
      xp(5, j) = -xk2(threadIdx%x, s_chan, 2)
      xp(6, j) = -xk1(threadIdx%x, s_chan, 3)
      xp(7, j) = -xk2(threadIdx%x, s_chan, 3)
      xp(8, j) = xj(threadIdx%x, s_chan, 4) - 0.5d0*(xk1(threadIdx%x, s_chan, 4) + xk2(threadIdx%x, s_chan, 4))

    enddo

    call syncthreads()

    !Always remember to release the channel

    if ((threadIdx%x .eq. 1) .and. (threadIdx%y .eq. 1) .and. (threadIdx%z .eq. 1)) then
      call releasechannel(socket, s_chan)
    endif

  end subroutine algorithm_test_kernel

subroutine eint2gpu(XP, NSYM, NBS, ZETA1, N1, N5, NTERM, NQNTM, CNORM1, B, NUMIN, NUMAX, LOCXP, LOCTR)
  use cudafor

  implicit none
  integer ::  nsym, maxnbs, l, m, p, q, r, s, i, j, maxr, maxs
  integer, parameter  ::  p_nsym = 7
  integer, dimension(p_nsym) :: nbs
  integer, device  ::  d_nsym, d_maxnbs
  integer, device, dimension(p_nsym)  ::  d_nbs
  type(dim3)  ::  gridDim, blockDim
  integer ::  maxthreadx, maxthready, maxthreadz
  real(kind = 8), dimension(:, :) ::  xp
  integer ::  sizemax1, sizemax2
  integer, device ::  d_sizemax
  real(kind = 8), device, allocatable,dimension(:, :) ::  d_xp
  real(kind = 8), dimension(n5, n1, 7)  ::  zeta1
  real(kind = 8), dimension(n1, 7)  ::  zeta2
  real(kind = 8),device, dimension(n1, 7) ::  d_zeta
  integer, dimension(2, 7)  ::  nterm
  integer, dimension(2, 2, 7) ::  nqntm
  real(kind = 8), dimension(2, n5, n1, 2, 7) ::  cnorm1
  real(kind = 8), dimension(n1, 7, 2, 2)  ::  cnorm2
  real(kind = 8), dimension(0:6, 7, 7)  ::  b
  integer, dimension(7, 7)  ::  numin, numax
  integer, dimension(:) ::  locxp, loctr
  integer, device, dimension(2, 7)  ::  d_nterm
  integer, device, dimension(2, 2, 7) ::  d_nqntm
  real(kind = 8), device, dimension(n1, 7, 2, 2) ::  d_cnorm
  real(kind = 8), device, dimension(0:6, 7, 7)  ::  d_b
  integer, device, dimension(7, 7)  ::  d_numin, d_numax
  integer, device, allocatable, dimension(:)  ::  d_locxp, d_loctr
  integer ::  n1, n5, mrs, lpq
  real(kind = 8), device, dimension(512, 14, 9, 2:20)  ::  d_c1, d_c2
  real(kind = 8), device, dimension(512, 14, 0:20)  ::  d_v1, d_v2
  real(kind = 8), device, dimension(512, 14, 4)  ::  d_xj, d_xk1, d_xk2
  integer, dimension(4) ::  ls1, ls2
  integer, device, dimension(4) ::  d_ls1, d_ls2
  integer ::  istat
  type(cudaEvent) ::  startEvent, stopEvent
  type(cudadeviceprop)  ::  prop
  integer ::  num_sm
  integer, device ::  d_num_sm
!  integer, allocatable, dimension(:)  ::  socket
  integer, device, allocatable, dimension(:)  ::  d_socket
  integer ::  occ ! The number of blocks running on each SMP, determine this with the occupancy calculator
  integer, allocatable, dimension(:, :) ::  lmpqrsarray
  integer, device, allocatable, dimension(:, :) ::  d_lmpqrsarray

  occ = 1

  maxnbs = 0

  do i = 1, nsym
    if (nbs(i) .gt. maxnbs) then
      maxnbs = nbs(i)
    endif
  enddo

! set up block dimensions, these values seem to work well for CC 2.0
  maxthreadx = 512
  maxthready = 1
  maxthreadz = 1

  ls1 = (/1, 1, 2, 2/)
  ls2 = (/1, 2, 1, 2/)

!rewrite zetas for gpu
  do i = 1, nsym
    do j = 1, nbs(i)
      zeta2(j, i) = zeta1(1, j, i)
    enddo
  enddo
 cnorm2 = 0
!rewrite cnorm for gpu
  do i = 1, nsym
    do j = 1, nbs(i)
      cnorm2(j, i, 1, 1) = cnorm1(1, 1, j, 1, i)
      cnorm2(j, i, 1, 2) = cnorm1(2, 1, j, 1, i)
      cnorm2(j, i, 2, 1) = cnorm1(1, 1, j, 2, i)
      cnorm2(j, i, 2, 2) = cnorm1(2, 1, j, 2, i)
    enddo
  enddo

!  write(6,*)cnorm2(1, 1, 2, 1)

  mrs = locxp(nsym) + loctr(nbs(nsym)) + nbs(nsym)                                
  lpq = locxp(nsym) + loctr(nbs(nsym)) + nbs(nsym)
  sizemax1 = ((LPQ-1)*LPQ)/2+MRS
  sizemax2 = size(xp,2)



  allocate(lmpqrsarray(sizemax1, 6), stat = istat)
  if (istat /= 0) stop 'Error during allocation of lmpqrsarray'

  call lmpqrsa(nsym, nbs, lmpqrsarray)

 
!  do j = 1, i-1
!    write(6, *) lmpqrsarray(j,1), lmpqrsarray(j,2), lmpqrsarray(j,3), lmpqrsarray(j,4), lmpqrsarray(j,5), lmpqrsarray(j,6)
!    write(6, *)'-------'
!  enddo


  istat = cudaGetDeviceProperties(prop, 0)
  num_sm = prop%multiProcessorCount*occ

  allocate(d_socket(num_sm), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_socket'
  allocate(d_xp(8, sizemax2), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_xp'
  allocate(d_locxp(size(locxp)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_locxp'
  allocate(d_loctr(size(loctr)), stat = istat)
  if (istat /= 0) stop 'Error during allocation of d_loctr'
  allocate(d_lmpqrsarray(sizemax1, 6), stat = istat)
  if (istat /= 0) stop 'Error during allocation of lmpqrsarray'

 ! xp2 = 0
 ! v1 = 0
 ! v2 = 0


! set up super-sturure dimensions
!  superx = ceiling(real(maxnbs)/real(maxthreadx))
!  supery = ceiling(real(maxnbs)/real(maxthready))
!  superz = ceiling(real(maxnbs)/real(maxthreadz))

  istat = cudaEventCreate(stopEvent)


! assign actual values
  blockDim = dim3(maxthreadx,maxthready,maxthreadz)
  gridDim = dim3(num_sm, 1, 1)


  d_sizemax = sizemax1
  d_lmpqrsarray = lmpqrsarray
  d_socket = 0
  d_num_sm = num_sm
 ! d_v1 = v1
 ! d_v2 = v2
  d_ls1 = ls1
  d_ls2 = ls2
  d_nsym = nsym
  d_nbs = nbs
  d_maxnbs = maxnbs
  d_zeta = zeta2
  d_nterm = nterm
  d_nqntm = nqntm
  d_cnorm = cnorm2
  d_b = b
  d_numin = numin
  d_numax = numax
  d_locxp = locxp
  d_loctr = loctr
!  d_xp = xp2
  call algorithm_test_kernel <<<gridDim, blockDim>>> (d_xp, d_nsym, d_nbs, d_zeta, d_nterm, &
& d_nqntm, d_cnorm, d_b, d_numin, d_numax, d_locxp, d_loctr, d_maxnbs,  &
& d_v1, d_v2, d_c1, d_c2, d_xj, d_xk1, d_xk2, d_ls1, d_ls2, d_socket, d_num_sm, d_lmpqrsarray, d_sizemax)


!  istat = cudaEventRecord(stopEvent,0)
!  istat = cudaEventSynchronize(stopEvent)



! m = 1, nsym
!    do s = 1, maxnbs
!      do r = 1, s
!        do l = 1, m
!          do q = 1, maxnbs
!            do p = 1, q
!              write(6,fmt = '(''<'',i1,'', '',i1,'', '',i1,", ",i1,">",i1,", ", i1)')conf(6,s,r,q,p,m,l),conf(5,s,r,q,p,m,l),conf(4,s,r,q,p,m,l),conf(3,s,r,q,p,m,l),conf(1,s,r,q,p,m,l),conf(2,s,r,q,p,m,l)
!            enddo
!          enddo
!        enddo
!      enddo
!    enddo
!  enddo
!  write(6,fmt='(i1,", ",i1," <", i1, ", ", i1, ", ", i1, ", ", i1,">")')conf
!  write(6,*)superx, supery, superz, gridDims
 ! c1 = d_c1
 ! c2 = d_c2
 ! xint = d_xint
 ! term = d_term
 ! v1 = d_v1
 ! v2 = d_v2
!  xj = d_xj
!  xk1 = d_xk1
!  xk2 = d_xk2
 ! npq = d_npq
 ! nrs = d_nrs
  xp = d_xp
  istat = cudaEventRecord(stopEvent,0)
  istat = cudaEventSynchronize(stopEvent)

!  write(6,*)'---'
!  write(6, *)c1(1, 1, 1, 1, 4, 1),c1(1, 1, 1, 2, 4, 1),c1(1, 1, 1, 3, 4, 1),c1(1, 1, 1, 4, 4, 1)
!  write(6,*)xj(1, 1, 1, 1), xj(1, 1, 1, 2), xj(1, 1, 1, 3), xj(1, 1, 1, 4)
!  write(6,*)xk1(1, 1, 1, 1), xk1(1, 1, 1, 2), xk1(1, 1, 1, 3), xk1(1, 1, 1, 4)
!  write(6,*)xk2(1, 1, 1, 1), xk2(1, 1, 1, 2), xk2(1, 1, 1, 3), xk2(1, 1, 1, 4)
!  write(6, *) term(1, 1, 1, 1), term(1, 1, 1, 2), term(1, 1, 1, 3), term(1, 1, 1, 4)
  
!  write(6, fmt='(a100)')'This is the starting point'
!  do i = 1, sizemax1
!    write(6, fmt = '(i0, 1x, 8(e25.16e3))')i, xp(1,i), xp(2,i), xp(3,i), xp(4,i), xp(5,i), xp(6,i), xp(7,i), xp(8,i) 
!  enddo

  deallocate(d_xp, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_xp'
  deallocate(d_socket, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_socket'
  deallocate(d_locxp, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_locxp'
  deallocate(d_loctr, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of d_loctr'
  deallocate(d_lmpqrsarray, stat = istat)
  if (istat /= 0) stop 'Error during deallocation of lmpqrsarray'

end subroutine eint2gpu

subroutine lmpqrsa(nsym, nbs, lmpqrsarray)
  implicit none

  integer ::  nsym, i, l, m, p, q, r, s, maxr, maxs
  integer, dimension(:) ::  nbs
  integer, dimension(:,:) ::  lmpqrsarray

  i = 1

  do l = 1, nsym
    do p = 1, nbs(l)
      do q = 1, p
        do m = 1, l
          maxr = nbs(m)
          if (l .eq. m) maxr = p
          do r = 1, maxr
            maxs = r
            if ((l .eq. m) .and. (p .eq. r)) maxs = q
            do s = 1, maxs
              lmpqrsarray(i,1) = l
              lmpqrsarray(i,2) = m
              lmpqrsarray(i,3) = p
              lmpqrsarray(i,4) = q
              lmpqrsarray(i,5) = r
              lmpqrsarray(i,6) = s
              i = i + 1
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
end subroutine lmpqrsa
end module
